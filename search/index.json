[{"content":"1. 概述 ZooKeeper 是一个开源的分布式协调服务，用于管理大型分布式系统的配置、命名、状态和组成员等。它提供了一组简单且健壮的原语，使得分布式系统中各节点可以协调它们的动作。\n2. 设计目标 ZooKeeper 的设计目标可以概括为以下几点：\n高可用性（High Availability）：ZooKeeper 集群通过冗余实现高可用性，即使部分节点故障，整个系统仍能正常工作。 高性能（High Performance）：ZooKeeper 的设计使得它能够处理大量的客户端请求。 强一致性（Strong Consistency）：ZooKeeper 保证数据在所有节点之间的一致性，即所有客户端看到的是同一份数据。 3. 数据模型 ZooKeeper 的数据模型类似于文件系统的层次结构，由一系列节点（ZNode）组成。每个 ZNode 都有一个路径唯一标识，例如 /path/to/node。\nzookeeper的数据结点可以视为树状结构(或目录)，树中的各个结点被称为znode(即zookeeper node)，一个znode可以由多个子结点。 zookeeper结点在结构上表现为树状；\n使用路径path来定位某个znode，比如/ns-1/itcast/mysqml/schemal1/table1，此处ns-1，itcast、mysql、schemal1、table1分别是根结点、2级 结点、3级结点以及4级结点；其中ns-1是itcast的父结点，itcast是ns-1的子结点，itcast是mysql的父结点\u0026hellip;.以此类推\nznode，间距文件和目录两种特点，即像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分\n3.1 一个znode大体上分为3个部分： 结点的数据：即znode data(结点path，结点data)的关系就像是Java map中的 key value关系\n结点的子结点children\n结点的状态stat：用来描述当前结点的创建、修改记录，包括cZxid、ctime等\n3.2 ZNode 类型 持久节点（Persistent Node）：创建后一直存在，直到被显式删除。（宕机仍存在） 临时节点（Ephemeral Node）：与客户端会话绑定，客户端断开连接时自动删除。（宕机或timeout时丢失） 顺序节点（Sequential Node）：在创建时自动在节点名后追加一个递增的序号。 持久顺序节点（Persistent Sequential Node） 和 临时顺序节点（Ephemeral Sequential Node）：结合了持久/临时和顺序节点的特性。 3.3 数据版本 ZooKeeper 为每个 ZNode 维护了三个版本号：\n数据版本（dataVersion）：每次数据变更时递增。 ACL 版本（aclVersion）：每次 ACL 变更时递增。 状态版本（czxid 版本）：每次节点创建或删除时递增。 4. 典型应用场景 配置管理：集中管理分布式系统的配置信息。 命名服务：为分布式系统中的服务提供统一的命名和发现机制。 分布式锁：实现分布式环境下的互斥锁。 组成员管理：动态管理分布式系统中的节点列表。 协调和通知：节点之间通过 ZooKeeper 进行协调和通知。 5. 内部机制 5.1 客户端与服务器架构 ZooKeeper 集群由多个服务器组成，每个服务器可以接受客户端的连接。客户端通过连接到任一服务器来访问 ZooKeeper 服务。客户端与服务器之间采用 TCP 连接，并且客户端会维护与服务器的心跳检测。\n5.2.1 集群角色 Leader：负责处理客户端请求，进行投票决策，维护集群状态。 Follower：跟随 Leader，接收 Leader 的指令，处理客户端请求（仅读请求）。 Observer：类似于 Follower，但不参与投票，仅用于扩展读能力。 5.2.2 集群角色 myid：每个 ZooKeeper 服务器都有一个唯一的 myid，用于标识自己。 zxid（ZooKeeper Transaction ID）：事务 ID，表示服务器上最后一次提交的事务。 epoch：逻辑时钟，用于区分不同的选举轮次。 5.3 Leader 选举 通过一种称为 Zab（ZooKeeper Atomic Broadcast）协议 的算法来实现的。Zab 协议是 ZooKeeper 的核心协议，用于保证分布式系统的一致性和可靠性。Leader 选举是 Zab 协议的重要组成部分，确保在集群中选出一个唯一的 Leader 来处理所有写请求。\nZooKeeper 的 Leader 选举分为两个阶段：\n发现阶段（Discovery Phase）：节点之间交换信息，确定当前的集群状态。 同步阶段（Synchronization Phase）：Leader 将最新的数据同步给其他节点。 5.3.1 选举触发条件 集群启动时，所有节点都处于 LOOKING 状态，开始选举。 当 Leader 宕机或失去连接时，Follower 会重新进入 LOOKING 状态，触发选举。 5.3.2 选举规则 每个节点在选举时会投票给自己或其他节点，投票的依据是：\n优先比较 zxid：zxid 最大的节点优先成为 Leader。 如果 zxid 相同，则比较 myid：myid 最大的节点优先成为 Leader。 5.3.3 选举流程 初始化状态： 所有节点启动时，初始状态为 LOOKING。 每个节点投票给自己，投票信息包括：(myid, zxid, epoch)。 交换投票信息： 节点之间通过 TCP 连接交换投票信息。 每个节点将自己的投票信息发送给其他节点。 处理投票： 每个节点收到其他节点的投票信息后，会进行比较： 如果收到的投票比自己的投票更优（zxid 更大，或者 zxid 相同但 myid 更大），则更新自己的投票。 否则，保持自己的投票不变。 统计投票： 每个节点统计收到的投票信息，如果某个节点获得了 大多数（Quorum） 的投票（即超过半数节点的支持），则该节点成为 Leader。 其他节点成为 Follower。 选举完成： 被选为 Leader 的节点状态变为 LEADING。 其他节点状态变为 FOLLOWING。 5.3.4 选举的容错机制 大多数原则（Quorum）： ZooKeeper 使用“大多数原则”来保证选举的正确性。只有获得大多数节点支持的节点才能成为 Leader。 例如，在一个 5 节点的集群中，至少需要 3 个节点同意才能选出 Leader。 防止脑裂（Split-Brain）： 通过大多数原则，ZooKeeper 可以防止网络分区导致的脑裂问题。如果集群被分割为多个部分，只有包含大多数节点的部分才能选出 Leader。 恢复机制： 如果 Leader 宕机，Follower 会重新触发选举，选出新的 Leader。 新 Leader 会通过 Zab 协议将最新的数据同步给其他节点，确保数据一致性。 5.4 数据同步 ZooKeeper 采用基于主从复制的同步机制。Leader 负责将数据变更日志（事务日志）发送给 Follower，Follower 按照相同的顺序应用日志，保证数据一致性。\n5.5 Watch 机制 ZooKeeper 提供了一种 Watch 机制，允许客户端在某个 ZNode 上注册Watcher。当 ZNode 的状态发生变化时，ZooKeeper 会向注册的客户端发送通知。\nwatcher概念 zookeeper提供了数据的 发布/订阅 功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容 改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者 zookeeper采用了 Watcher机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 Watcher注册后轮询阻塞，从而减轻了客户端压力 watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式 watcher架构 watcher实现由三个部分组成\nzookeeper服务端 zookeeper客户端 客户端的ZKWatchManager对象 客户端首先将 Watcher注册到服务端，同时将 Watcher对象保存到客户端的watch管理器中。当Zookeeper服务端监听的数据状态发生变化时， 服务端会主动通知客户端，接着客户端的 Watch管理器会触发相关 Watcher来回调相应处理逻辑，从而完成整体的数据 发布/订阅 流程。\n6. 一致性保障 ZooKeeper 通过以下机制保证数据一致性：\n原子性：所有操作要么全部成功，要么全部失败。 顺序一致性：来自同一客户端的请求按顺序执行。 强一致性：所有客户端看到的是同一份数据。 7. 优缺点 优点 简单易用：提供简单易用的 API，易于集成到分布式系统中。 高可用性：通过冗余节点保证服务的高可用性。 强一致性：保证数据在所有节点之间的一致性。 缺点 性能受限：虽然性能较高，但仍然存在单点性能瓶颈（Leader 节点）。 复杂性：内部机制相对复杂，维护成本较高。 8. 适用场景 ZooKeeper 适用于以下场景：\n配置管理：集中管理分布式系统的配置信息。 命名服务：为分布式系统中的服务提供统一的命名和发现机制。 分布式锁和协调：实现分布式环境下的互斥锁和协调机制。 集群管理：动态管理集群节点，实现故障转移和负载均衡。 9. 总结 ZooKeeper 是一个功能强大且广泛应用的分布式协调服务，适用于各种分布式系统的协调和管理。其简单易用的 API 和强大的一致性保证，使得它成为构建分布式系统的重要组件。然而，理解和正确使用 ZooKeeper 也需要一定的知识和经验，特别是在处理一致性、性能和高可用性方面。\nwatch机制demo 下面是一个使用 ZooKeeper Watch 机制的简单示例。这个示例展示了如何使用 Java 客户端连接到 ZooKeeper 服务器，并在一个节点上设置 Watcher，当节点数据发生变化时，客户端会收到通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import org.apache.zookeeper.WatchedEvent; import org.apache.zookeeper.Watcher; import org.apache.zookeeper.ZooKeeper; import org.apache.zookeeper.CreateMode; import org.apache.zookeeper.ZooDefs; import org.apache.zookeeper.KeeperException; import java.io.IOException; import java.util.concurrent.CountDownLatch; public class ZookeeperWatchDemo { // ZooKeeper 连接地址 private static final String ZK_ADDRESS = \u0026#34;localhost:2181\u0026#34;; // ZooKeeper 会话超时时间 private static final int SESSION_TIMEOUT = 3000; // 用于等待连接建立的信号量 private static final CountDownLatch connectedSignal = new CountDownLatch(1); // ZooKeeper 实例 private static ZooKeeper zooKeeper; public static void main(String[] args) throws IOException, InterruptedException, KeeperException { // 创建 ZooKeeper 连接 zooKeeper = new ZooKeeper(ZK_ADDRESS, SESSION_TIMEOUT, new Watcher() { @Override public void process(WatchedEvent event) { if (event.getState() == Event.KeeperState.SyncConnected) { // 连接建立后，释放信号量 connectedSignal.countDown(); } } }); // 等待连接建立 connectedSignal.await(); System.out.println(\u0026#34;Connected to ZooKeeper!\u0026#34;); // 创建持久节点 String path = \u0026#34;/testWatchNode\u0026#34;; if (zooKeeper.exists(path, false) == null) { zooKeeper.create(path, \u0026#34;initialData\u0026#34;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); System.out.println(\u0026#34;Node created: \u0026#34; + path); } // 设置 Watcher watchNode(path); // 模拟节点数据变化 zooKeeper.setData(path, \u0026#34;newData\u0026#34;.getBytes(), -1); System.out.println(\u0026#34;Node data updated.\u0026#34;); // 保持程序运行，以便观察 Watcher 触发 Thread.sleep(10000); // 关闭连接 zooKeeper.close(); } /** * 设置 Watcher 监听节点数据变化 */ private static void watchNode(String path) throws KeeperException, InterruptedException { // 获取节点数据，并设置 Watcher byte[] data = zooKeeper.getData(path, new Watcher() { @Override public void process(WatchedEvent event) { if (event.getType() == Event.EventType.NodeDataChanged) { System.out.println(\u0026#34;Node data changed: \u0026#34; + event.getPath()); try { // 重新设置 Watcher watchNode(path); } catch (KeeperException | InterruptedException e) { e.printStackTrace(); } } } }, null); System.out.println(\u0026#34;Current node data: \u0026#34; + new String(data)); } } 运行结果 1 2 3 4 5 6 Connected to ZooKeeper! Node created: /testWatchNode Current node data: initialData Node data updated. Node data changed: /testWatchNode Current node data: newData 代码说明 ZooKeeper 连接： 使用 ZooKeeper 类连接到 ZooKeeper 服务器。 通过 CountDownLatch 确保连接建立后再执行后续操作。 创建节点： 使用 zooKeeper.create() 方法创建一个持久节点 /testWatchNode，并设置初始数据。 设置 Watcher： 使用 zooKeeper.getData() 方法获取节点数据，并设置一个 Watcher。 当节点数据发生变化时，Watcher 的 process() 方法会被调用，打印变化信息，并重新设置 Watcher。 模拟节点数据变化： 使用 zooKeeper.setData() 方法更新节点数据，触发 Watcher。 保持程序运行： 使用 Thread.sleep() 保持程序运行，以便观察 Watcher 触发。 关闭连接： 使用 zooKeeper.close() 方法关闭 ZooKeeper 连接。 ","date":"2024-12-15T23:39:10+08:00","image":"https://deisbeir.github.io/p/zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9/show_hu5419634950751519576.png","permalink":"https://deisbeir.github.io/p/zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"Zookeeper知识点"},{"content":"NIO 基本概念 阻塞（Block）与非阻塞（Non-Block） 阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式，当数据没有准备的时候。\n阻塞：往往需要等待缓冲区中的数据准备好过后才处理其他的事情，否则一直等待在那里。\n非阻塞:当我们的进程访问我们的数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据已经准备好，也直接返回。\n阻塞 IO ：\n非阻塞 IO ：\n同步（Synchronous）与异步（Asynchronous） 同步和异步都是基于应用程序和操作系统处理 IO 事件所采用的方式。比如\n**同步：**是应用程序要直接参与 IO 读写的操作。\n**异步：**所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知。\n同步方式在处理 IO 事件的时候，必须阻塞在某个方法上面等待我们的 IO 事件完成（阻塞 IO 事件或者通过轮询 IO事件的方式），对于异步来说，所有的 IO 读写都交给了操作系统。这个时候，我们可以去做其他的事情，并不需要去完成真正的 IO 操作，当操作完成 IO 后，会给我们的应用程序一个通知。\n所以异步相比较于同步带来的直接好处就是在我们处理IO数据的时候，异步的方式我们可以把这部分等待所消耗的资源用于处理其他事务，提升我们服务自身的性能。\n**同步 IO **：\n**异步 IO **：\nJava BIO与NIO对比 BIO（传统IO）： BIO是一个同步并阻塞的IO模式，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。\nNIO（Non-blocking/New I/O） NIO 是一种同步非阻塞的 I/O 模型，于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发\nBIO与NIO的对比 IO模型 BIO NIO 通信 面向流 面向缓冲 处理 阻塞 IO 非阻塞 IO 触发 无 选择器 NIO 的 Server 通信的简单模型： BIO 的 Server 通信的简单模型： NIO的特点： 一个线程可以处理多个通道，减少线程创建数量； 读写非阻塞，节约资源：没有可读／可写数据时，不会发生阻塞导致线程资源的浪费 Reactor 模型 单线程的 Reactor 模型 多线程的 Reactor 模型 多线程主从 Reactor 模型 Netty 基础概念 Netty 简介 Netty 是一个 NIO 客户端服务器框架，可快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化和简化了网络编程，例如 TCP 和 UDP 套接字服务器。\nNetty 执行流程 Netty 核心组件 Channel Channel是 Java NIO 的一个基本构造。可以看作是传入或传出数据的载体。因此，它可以被打开或关闭，连接或者断开连接。\nEventLoop 与 EventLoopGroup EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。\nEventLoopGroup 是一个 EventLoop 池，包含很多的 EventLoop。\nNetty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。\n一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。\nServerBootstrap 与 Bootstrap Bootstarp 和 ServerBootstrap 被称为引导类，指对应用程序进行配置，并使他运行起来的过程。Netty处理引导的方式是使你的应用程序和网络层相隔离。\nBootstrap 是客户端的引导类，Bootstrap 在调用 bind()（连接UDP）和 connect()（连接TCP）方法时，会新创建一个 Channel，仅创建一个单独的、没有父 Channel 的 Channel 来实现所有的网络交换。\nServerBootstrap 是服务端的引导类，ServerBootstarp 在调用 bind() 方法时会创建一个 ServerChannel 来接受来自客户端的连接，并且该 ServerChannel 管理了多个子 Channel 用于同客户端之间的通信。\nChannelHandler 与 ChannelPipeline ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。\nChannelFuture Netty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。\nNetty 的异步编程模型都是建立在 Future 与回调概念之上的。\n启动Demo 以下是一个完整的 Netty 启动 Demo，包括一个简单的 服务端 和 客户端 实现。这个 Demo 展示了如何使用 Netty 构建一个基本的网络应用。\n1. Netty 服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.*; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; public class NettyServer { public static void main(String[] args) throws InterruptedException { // 创建两个 EventLoopGroup EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 用于处理客户端连接 EventLoopGroup workerGroup = new NioEventLoopGroup(); // 用于处理 I/O 操作 try { // 创建 ServerBootstrap ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) // 使用 NIO 传输通道 .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 添加字符串编解码器 pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); // 添加自定义的处理器 pipeline.addLast(new ServerHandler()); } }) .option(ChannelOption.SO_BACKLOG, 128) // 设置连接队列大小 .childOption(ChannelOption.SO_KEEPALIVE, true); // 保持长连接 // 绑定端口并启动服务端 ChannelFuture future = serverBootstrap.bind(8080).sync(); System.out.println(\u0026#34;Netty 服务端启动成功，监听端口：8080\u0026#34;); // 等待服务端关闭 future.channel().closeFuture().sync(); } finally { // 优雅关闭 EventLoopGroup bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } // 自定义的处理器 private static class ServerHandler extends SimpleChannelInboundHandler\u0026lt;String\u0026gt; { @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { // 处理接收到的消息 System.out.println(\u0026#34;服务端收到消息: \u0026#34; + msg); // 回复客户端 ctx.writeAndFlush(\u0026#34;Hello, 客户端！\u0026#34;); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { // 处理异常 cause.printStackTrace(); ctx.close(); } } } 2. Netty 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import io.netty.bootstrap.Bootstrap; import io.netty.channel.*; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; public class NettyClient { public static void main(String[] args) throws InterruptedException { // 创建 EventLoopGroup EventLoopGroup group = new NioEventLoopGroup(); try { // 创建 Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) // 使用 NIO 传输通道 .handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 添加字符串编解码器 pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); // 添加自定义的处理器 pipeline.addLast(new ClientHandler()); } }); // 连接服务端 ChannelFuture future = bootstrap.connect(\u0026#34;127.0.0.1\u0026#34;, 8080).sync(); System.out.println(\u0026#34;Netty 客户端启动成功，连接到服务端\u0026#34;); // 发送消息 future.channel().writeAndFlush(\u0026#34;Hello, 服务端！\u0026#34;); // 等待客户端关闭 future.channel().closeFuture().sync(); } finally { // 优雅关闭 EventLoopGroup group.shutdownGracefully(); } } // 自定义的处理器 private static class ClientHandler extends SimpleChannelInboundHandler\u0026lt;String\u0026gt; { @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { // 处理接收到的消息 System.out.println(\u0026#34;客户端收到消息: \u0026#34; + msg); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { // 处理异常 cause.printStackTrace(); ctx.close(); } } } 3. 运行步骤 启动服务端： 运行 NettyServer 类的 main 方法。 服务端会监听 8080 端口，等待客户端连接。 启动客户端： 运行 NettyClient 类的 main 方法。 客户端会连接到服务端，并发送一条消息。 查看输出： 服务端会打印：服务端收到消息: Hello, 服务端！。 客户端会打印：客户端收到消息: Hello, 客户端！。 4. 代码说明 服务端： 使用 ServerBootstrap 启动服务端。 监听 8080 端口，处理客户端连接和消息。 使用 StringDecoder 和 StringEncoder 处理字符串消息。 自定义 ServerHandler 处理业务逻辑。 客户端： 使用 Bootstrap 启动客户端。 连接到服务端的 8080 端口，发送消息。 使用 StringDecoder 和 StringEncoder 处理字符串消息。 自定义 ClientHandler 处理业务逻辑。 ","date":"2024-12-14T23:39:10+08:00","image":"https://deisbeir.github.io/p/netty%E7%9F%A5%E8%AF%86%E7%82%B9/show_hu18369183166602136193.png","permalink":"https://deisbeir.github.io/p/netty%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"Netty知识点"},{"content":"JVM 学习笔记 1. JVM 概述 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。Java 虚拟机（JVM）是 Java 程序运行的核心组件，负责将 Java 字节码转换为机器码并执行。JVM 提供了跨平台的能力，使得 Java 程序能够“一次编写，到处运行”。JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。\n1.1 Java文件是如何被运行的 比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，就类似于一个文本文件。\n而 JVM 是不认识文本文件的，所以它需要进行 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class\n类加载器 如果 JVM 想要执行这个 .class 文件，需要将其装进一个 类加载器 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面来。\n方法区 方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等\n类加载器将 .class 文件搬过来就是先丢到这一块上\n堆 堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 线程不安全 的。\n栈 栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。\n我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。\n程序计数器 主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 线程独享 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。\nJava 文件经过编译后变成 .class 字节码文件。\n字节码文件通过类加载器被搬运到 JVM 虚拟机中。\n虚拟机主要的 5 大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行。\n2. JVM 的核心原理 2.1 类加载机制 2.1.1 类加载过程 加载（Loading）：\n通过类加载器将 .class 文件加载到内存中。 类加载器根据类的全限定名查找字节码文件，并将其转换为 JVM 内部的类对象。 加载阶段是类加载的第一步，后续的验证、准备、解析和初始化都依赖于加载的结果。 验证（Verification）：\n确保字节码符合 JVM 规范，防止恶意代码。 验证的内容包括： 文件格式验证：检查字节码文件是否符合 JVM 规范。 元数据验证：检查类的元数据是否符合 Java 语言规范。 字节码验证：检查字节码是否合法，是否存在栈溢出、类型不匹配等问题。 符号引用验证：确保符号引用能够正确解析。 准备（Preparation）：\n为静态变量分配内存并设置默认值。 例如，static int value = 123; 在准备阶段，value 会被初始化为 0，而不是 123。 如果静态变量是常量（final），则会在准备阶段直接赋值。 解析（Resolution）：\n将符号引用转换为直接引用。 符号引用是类、方法、字段的名称和描述符，直接引用是内存地址或偏移量。 解析阶段可能触发其他类的加载。 初始化（Initialization）：\n执行静态代码块和静态变量的赋值。 初始化阶段是类加载的最后一步，只有当类被主动使用时才会触发。 例如，static { value = 123; } 会在初始化阶段执行。 其中验证，准备，解析三个部分统称为连接\n类加载器的层级结构： 加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的\nBootstrap Class Loader：加载核心 Java 类库（如 java.lang.*），由 JVM 实现，通常用 C/C++ 编写。 Extension Class Loader：加载扩展类库（jre/lib/ext 目录下的类）。 Application Class Loader：加载应用程序类路径（Classpath）中的类。 2.1.2 双亲委派模型 类加载器在加载类时，首先委托父类加载器尝试加载，只有在父类加载器无法加载时，才由自己加载。这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果 优点： 保证核心类库的安全性，避免用户自定义类替换核心类。 避免重复加载，提高加载效率。 2.1.3 自定义类加载器 可以通过继承 ClassLoader 类实现自定义类加载器。 典型应用场景： 热部署：动态加载修改后的类。 隔离类加载：实现类加载的隔离，避免类冲突。 加密类加载：加载加密的字节码文件。 2.2 运行时数据区 2.2.1 方法区（Method Area） 存储类的元数据、常量、静态变量等。 在 JDK 8 之前称为“永久代（PermGen）”，之后被“元空间（Metaspace）”取代。 元空间使用本地内存，不再受 JVM 堆内存限制，减少了内存溢出的风险。 主要存储： 类的结构信息（如方法、字段、构造函数等）。 运行时常量池（Runtime Constant Pool）。 静态变量。 2.2.2 堆（Heap） 存储对象实例和数组。 是垃圾回收的主要区域。 分为新生代（Young Generation）和老年代（Old Generation）： 新生代： 分为 Eden 区和两个 Survivor 区（From 和 To）。 新创建的对象首先分配在 Eden 区。 当 Eden 区满时，触发 Minor GC，存活的对象被移动到 Survivor 区。 经过多次 Minor GC 后仍然存活的对象会被移动到老年代。 老年代： 存储长期存活的对象。 当老年代满时，触发 Full GC，回收整个堆内存。 非堆内存则为永久代。 2.2.3 栈（Stack） 是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈。\n每个线程拥有独立的栈，用于存储局部变量、方法调用和部分结果。 栈帧（Stack Frame）是栈的基本单位，每个方法调用对应一个栈帧。 栈帧包括： 局部变量表：存储方法的局部变量。 操作数栈：用于执行字节码指令。 动态链接：指向运行时常量池的方法引用。 方法返回地址：记录方法执行完毕后的返回地址。 对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。 2.2.4 程序计数器（Program Counter Register） 记录当前线程执行的字节码指令地址。 线程私有，不会发生内存溢出。 在多线程环境下，每个线程都有自己的程序计数器，用于记录线程的执行位置。 2.2.5 本地方法栈（Native Method Stack） 为本地方法（Native Method）服务，与栈类似。 本地方法是用其他语言（如 C/C++）编写的方法，通过 JNI（Java Native Interface）调用。 2.3 执行引擎 2.3.1 解释器（Interpreter） 逐行解释字节码并执行。 优点：启动速度快，适合短生命周期的应用。 缺点：执行效率较低，适合开发环境或小型应用。 2.3.2 即时编译器（JIT Compiler） 将热点代码（频繁执行的代码）编译为机器码，提高执行效率。 主要的 JIT 编译器： C1 编译器：适用于客户端应用，编译速度快，优化程度较低。 C2 编译器：适用于服务器端应用，优化程度高，编译速度较慢。 JIT 编译器的工作流程： 监控代码执行频率，识别热点代码。 将热点代码编译为机器码。 替换解释器执行的字节码，直接执行机器码。 2.3.3 垃圾回收器（Garbage Collector） 自动回收不再使用的对象，释放内存。 常见的垃圾回收算法： 标记-清除（Mark-Sweep）： 标记所有存活的对象，清除未标记的对象。 缺点：产生内存碎片。 标记-整理（Mark-Compact）： 标记所有存活的对象，将存活对象移动到内存的一端，清除剩余内存。 优点：避免内存碎片。 复制算法（Copying）： 将内存分为两块，每次只使用一块，将存活对象复制到另一块，清除当前块。 优点：避免内存碎片，适合新生代。 分代收集（Generational Collection）： 根据对象的生命周期将堆内存分为新生代和老年代，分别采用不同的垃圾回收算法。 3. JVM 在项目中的运用 3.1 JVM 调优 3.1.1 内存设置 堆内存： -Xms：初始堆大小。 -Xmx：最大堆大小。 新生代与老年代比例： -XX:NewRatio：新生代与老年代的比例。 -XX:SurvivorRatio：Eden 区与 Survivor 区的比例。 3.1.2 垃圾回收器选择 串行垃圾回收器：-XX:+UseSerialGC，适用于单核 CPU。 并行垃圾回收器：-XX:+UseParallelGC，适用于多核 CPU。 G1 垃圾回收器：-XX:+UseG1GC，适用于大内存应用。 3.2 性能监控与问题排查 3.2.1 监控工具 jstat：监控 JVM 统计信息，如堆内存使用情况、垃圾回收次数等。 jmap：生成堆内存快照，分析内存占用。 jstack：生成线程快照，排查死锁或线程阻塞问题。 VisualVM：图形化工具，监控内存、线程、CPU 使用情况。 3.2.2 常见问题与解决方案 内存泄漏：使用 jmap 生成堆转储文件，分析对象引用链，找到未释放的对象。 CPU 占用过高：使用 jstack 查看线程堆栈，定位高 CPU 占用的线程。 频繁 Full GC：调整堆内存大小或优化垃圾回收器参数。 3.3 本地方法接口（JNI） 用途：调用本地方法（如 C/C++ 代码），适用于需要高性能或调用现有库的场景。 流程： 在 Java 中声明本地方法。 使用 javah 生成头文件。 在 C/C++ 中实现本地方法。 将本地库加载到 JVM 中。 4. 实践建议 深入理解 JVM 原理：通过阅读官方文档和相关书籍，掌握 JVM 的核心概念和工作机制。 结合实际项目调优：根据应用场景调整 JVM 参数，监控性能指标，优化垃圾回收策略。 使用工具排查问题：熟练掌握 jstat、jmap、jstack 等工具，快速定位和解决性能问题。 关注 JVM 发展趋势：了解新版本 JVM 的特性和优化，如 ZGC、GraalVM 等。 5. 总结 JVM 是 Java 生态系统的核心，理解其原理和调优方法对于开发高性能、稳定的 Java 应用至关重要。通过深入学习 JVM 的内存管理、类加载机制、执行引擎等核心组件，并结合实际项目中的调优和问题排查，可以显著提升应用的性能和可靠性。\n","date":"2024-12-12T17:23:34+08:00","image":"https://deisbeir.github.io/p/jvm/show_hu3054901689923059314.png","permalink":"https://deisbeir.github.io/p/jvm/","title":"Jvm"},{"content":"策略模式 模式的意图 在软件开发中，经常会遇到需要根据不同的条件来实现不同行为的场景。这种场景下，策略模式（Strategy Pattern）就是一种非常有用的设计模式。\n策略模式属于行为型模式，允许我们定义一系列算法，并将其封装在独立的策略类中，使得它们可以互相替换。通过使用策略模式，我们能够灵活地选择和切换不同的算法，而无需修改原有的代码，替代⼤量 if else 的逻辑。\n动机 当存在多种实现方式，且需要在运行时动态选择具体实现时，策略模式非常有用。例如，一个购物应用可能需要根据用户的会员等级来计算折扣，不同等级对应不同的计算方式，这时就可以使用策略模式来实现。 当存在一组类似的行为，只是实现细节略有不同，但又不希望通过继承来添加新的子类时，策略模式也很适用。它将这组行为封装在独立的策略类中，并通过委托的方式在上下文对象中使用。 例如 支付方式选择：一个电子商务平台可以根据用户的选择来使用不同的支付策略，例如信用卡支付、支付宝支付、微信支付等。 类结构 在策略模式中，有三个核心角色：上下文（Context）、策略接口（Strategy）和具体策略类（Concrete Strategy）。\n上下文（Context）：封装了具体策略的执行逻辑，提供给客户端使用的接口。上下文通常包含一个指向策略接口的引用，用于调用具体策略的方法。 策略接口（Strategy）：定义了一组算法或行为的公共接口，所有具体策略都必须实现该接口。 具体策略类（Concrete Strategy）：实现了策略接口，提供了具体的算法或行为。 代码示例 接下来以支付方式选择为例，展示代码\n上下文类\n1 2 3 4 5 6 7 8 9 10 11 12 // 上下文类 public class PaymentContext { private PaymentStrategy paymentStrategy; public PaymentContext(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void pay(double amount) { paymentStrategy.pay(amount); } } 策略接口\n1 2 3 4 //策略接口 public interface PaymentStrategy { void pay(double amount); } 策略接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //具体策略类 public class CreditCardPayment implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } } public class WeChatPay implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 // 使用示例 public class Main { public static void main(String[] args) { PaymentStrategy strategy = new CreditCardPayment(); PaymentContext context = new PaymentContext(strategy); context.pay(100.0); strategy = new WeChatPay(); context = new PaymentContext(strategy); context.pay(200.0); } } 输出\n1 2 使用信用卡支付：100.0 使用微信支付：200.0 策略模式的优缺点 策略模式的优点包括：\n松耦合：策略模式将不同的策略封装在独立的类中，与上下文对象解耦，增加了代码的灵活性和可维护性。 易于扩展：可以通过添加新的策略类来扩展系统的功能，无需修改现有代码。 符合开闭原则：对于新的策略，无需修改上下文对象，只需要实现新的策略接口即可。 策略模式的缺点包括：\n类数量增多：每个具体策略都需要一个独立的类，如果策略较多，将导致类的数量增加。 上层必须知道所有策略类：上层模块必须知道有哪些策略，并选择合适的策略进行使用，这与迪米特法则是相违背的。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题，否则日后的系统维护就会成为一个烫手山芋。\n策略模式的优化 使用Map取消 Context 类 我们可以将策略实现类放进 Map 中，根据 key 去选择具体的策略，就不必事先定义 Context 类。\n1 2 3 4 5 6 7 8 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategy\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, new CreditCardPayment()); map.put(\u0026#34;WECHAT_PAY\u0026#34;,new WeChatPay()); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 策略枚举解决策略类膨胀 策略枚举可以解决策略类过多的问题。\n我们对原装的策略模式进行改造，把原有定义在抽象策略中的方法移植到枚举中，让枚举成员成为一个具体策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Slf4j public enum PaymentStrategyEnum { CREDIT_CARD { @Override public void pay(double amount) { log.info(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } }, WECHAT_PAY { @Override public void pay(double amount) { log.info(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } }; public abstract void pay(double amount); } 在上面的代码中，我们定义了一个枚举类型 PaymentStrategy，其中包含两个枚举常量 CREDIT_CARD 和 WECHAT_PAY。每个枚举常量都重写了 pay() 方法，用于具体的支付逻辑\n1 2 3 4 5 6 7 8 9 // 使用示例 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategyEnum\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, PaymentStrategyEnum.CREDIT_CARD); map.put(\u0026#34;WECHAT_PAY\u0026#34;, PaymentStrategyEnum.WECHAT_PAY); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 注意：策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是 public、final、static 的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。\nSpringBoot中的策略模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public interface Test { void print(String name); } @Service(\u0026#34;testA\u0026#34;) @Slf4j public class TestA implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类A\u0026#34;+name); } } @Service(\u0026#34;testB\u0026#34;) @Slf4j public class TestB implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类B\u0026#34;+name); } } 使用的时候 @Autowired 或者 @Resource 即可，SpringBoot会帮我们把实现类自动注入注入Map。\n1 2 3 4 5 @Resource private Map\u0026lt;String,Test\u0026gt; map; Test test = map.get(\u0026#34;你想拿出的具体策略类\u0026#34;); test.print(\u0026#34;hello world\u0026#34;); 总结 策略模式是一种强大而灵活的设计模式，它可以帮助我们处理不同的算法或行为，并使系统更具可维护性和扩展性。通过封装具体的策略类和使用上下文对象，我们可以轻松地选择和切换不同的策略，而无需修改现有的代码。\n","date":"2024-12-10T23:48:54+08:00","image":"https://deisbeir.github.io/p/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/show_hu7614944383175808824.png","permalink":"https://deisbeir.github.io/p/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","title":"策略模式"},{"content":"常见设计模式总结 我打算再理一遍常见的设计模式以加深印象，在这里先记录最基本的一些概念。\n什么是设计模式？ 设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，你可以根据需要进行定制，以解决代码中反复出现的设计问题。\n模式不是一段具体的代码，而是一个解决特定问题的通用概念。你可以遵循模式的思路，实现一个适合你自己程序实际情况的解决方案。\n为什么应该学习设计模式？ 设计模式是解决软件设计中常见问题的经过验证的工具包。它会教你如何使用面向对象设计的原则来解决各种问题。\n设计模式定义了一种通用的语言，团队成员可以使用它更高效地进行沟通。能更好的应对变更。同时在解决某些问题时会给出灵感。\n实际上，不使用设计模式也可以完成很多程序、项目，但使用设计模式会帮你避免后续的很多麻烦、节约沟通成本、使你的代码更加优雅。\n每个设计模式都可以通过以下几个部分来理解 模式的意图：简要描述问题和解决方案。 动机：进一步解释问题以及模式如何提供解决方案。 类结构：展示模式中每个部分以及它们之间的关系。 代码示例：使用一种流行的编程语言编写的代码示例，帮助更容易理解模式背后的思想。 六大设计原则 单一职责原则 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。\n该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：\n一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 开放封闭原则 开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n里式替换原则 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\n迪米特法则 迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)。\n迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n接口隔离原则 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。\n要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。\n接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\n单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。\n由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。\n使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。\n合成复用原则(CRP) 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。\n简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。\n类图基础 ","date":"2024-12-10T22:54:14+08:00","image":"https://deisbeir.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/show_hu16453722202888260347.png","permalink":"https://deisbeir.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/","title":"设计模式基础"},{"content":"这是我的第一篇博客 我会尽可能的记录我所学习的内容！\n","date":"2024-12-10T21:48:01+08:00","permalink":"https://deisbeir.github.io/p/hellow/","title":"Hellow"}]