[{"content":"JVM 学习笔记 1. JVM 概述 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。Java 虚拟机（JVM）是 Java 程序运行的核心组件，负责将 Java 字节码转换为机器码并执行。JVM 提供了跨平台的能力，使得 Java 程序能够“一次编写，到处运行”。JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。\n1.1 Java文件是如何被运行的 比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，就类似于一个文本文件。\n而 JVM 是不认识文本文件的，所以它需要进行 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class\n类加载器 如果 JVM 想要执行这个 .class 文件，需要将其装进一个 类加载器 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面来。\n方法区 方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等\n类加载器将 .class 文件搬过来就是先丢到这一块上\n堆 堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 线程不安全 的。\n栈 栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。\n我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。\n程序计数器 主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 线程独享 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。\nJava 文件经过编译后变成 .class 字节码文件。\n字节码文件通过类加载器被搬运到 JVM 虚拟机中。\n虚拟机主要的 5 大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行。\n2. JVM 的核心原理 2.1 类加载机制 2.1.1 类加载过程 加载（Loading）：\n通过类加载器将 .class 文件加载到内存中。 类加载器根据类的全限定名查找字节码文件，并将其转换为 JVM 内部的类对象。 加载阶段是类加载的第一步，后续的验证、准备、解析和初始化都依赖于加载的结果。 验证（Verification）：\n确保字节码符合 JVM 规范，防止恶意代码。 验证的内容包括： 文件格式验证：检查字节码文件是否符合 JVM 规范。 元数据验证：检查类的元数据是否符合 Java 语言规范。 字节码验证：检查字节码是否合法，是否存在栈溢出、类型不匹配等问题。 符号引用验证：确保符号引用能够正确解析。 准备（Preparation）：\n为静态变量分配内存并设置默认值。 例如，static int value = 123; 在准备阶段，value 会被初始化为 0，而不是 123。 如果静态变量是常量（final），则会在准备阶段直接赋值。 解析（Resolution）：\n将符号引用转换为直接引用。 符号引用是类、方法、字段的名称和描述符，直接引用是内存地址或偏移量。 解析阶段可能触发其他类的加载。 初始化（Initialization）：\n执行静态代码块和静态变量的赋值。 初始化阶段是类加载的最后一步，只有当类被主动使用时才会触发。 例如，static { value = 123; } 会在初始化阶段执行。 其中验证，准备，解析三个部分统称为连接\n类加载器的层级结构： 加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的\nBootstrap Class Loader：加载核心 Java 类库（如 java.lang.*），由 JVM 实现，通常用 C/C++ 编写。 Extension Class Loader：加载扩展类库（jre/lib/ext 目录下的类）。 Application Class Loader：加载应用程序类路径（Classpath）中的类。 2.1.2 双亲委派模型 类加载器在加载类时，首先委托父类加载器尝试加载，只有在父类加载器无法加载时，才由自己加载。这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果 优点： 保证核心类库的安全性，避免用户自定义类替换核心类。 避免重复加载，提高加载效率。 2.1.3 自定义类加载器 可以通过继承 ClassLoader 类实现自定义类加载器。 典型应用场景： 热部署：动态加载修改后的类。 隔离类加载：实现类加载的隔离，避免类冲突。 加密类加载：加载加密的字节码文件。 2.2 运行时数据区 2.2.1 方法区（Method Area） 存储类的元数据、常量、静态变量等。 在 JDK 8 之前称为“永久代（PermGen）”，之后被“元空间（Metaspace）”取代。 元空间使用本地内存，不再受 JVM 堆内存限制，减少了内存溢出的风险。 主要存储： 类的结构信息（如方法、字段、构造函数等）。 运行时常量池（Runtime Constant Pool）。 静态变量。 2.2.2 堆（Heap） 存储对象实例和数组。 是垃圾回收的主要区域。 分为新生代（Young Generation）和老年代（Old Generation）： 新生代： 分为 Eden 区和两个 Survivor 区（From 和 To）。 新创建的对象首先分配在 Eden 区。 当 Eden 区满时，触发 Minor GC，存活的对象被移动到 Survivor 区。 经过多次 Minor GC 后仍然存活的对象会被移动到老年代。 老年代： 存储长期存活的对象。 当老年代满时，触发 Full GC，回收整个堆内存。 非堆内存则为永久代。 2.2.3 栈（Stack） 是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈。\n每个线程拥有独立的栈，用于存储局部变量、方法调用和部分结果。 栈帧（Stack Frame）是栈的基本单位，每个方法调用对应一个栈帧。 栈帧包括： 局部变量表：存储方法的局部变量。 操作数栈：用于执行字节码指令。 动态链接：指向运行时常量池的方法引用。 方法返回地址：记录方法执行完毕后的返回地址。 对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。 2.2.4 程序计数器（Program Counter Register） 记录当前线程执行的字节码指令地址。 线程私有，不会发生内存溢出。 在多线程环境下，每个线程都有自己的程序计数器，用于记录线程的执行位置。 2.2.5 本地方法栈（Native Method Stack） 为本地方法（Native Method）服务，与栈类似。 本地方法是用其他语言（如 C/C++）编写的方法，通过 JNI（Java Native Interface）调用。 2.3 执行引擎 2.3.1 解释器（Interpreter） 逐行解释字节码并执行。 优点：启动速度快，适合短生命周期的应用。 缺点：执行效率较低，适合开发环境或小型应用。 2.3.2 即时编译器（JIT Compiler） 将热点代码（频繁执行的代码）编译为机器码，提高执行效率。 主要的 JIT 编译器： C1 编译器：适用于客户端应用，编译速度快，优化程度较低。 C2 编译器：适用于服务器端应用，优化程度高，编译速度较慢。 JIT 编译器的工作流程： 监控代码执行频率，识别热点代码。 将热点代码编译为机器码。 替换解释器执行的字节码，直接执行机器码。 2.3.3 垃圾回收器（Garbage Collector） 自动回收不再使用的对象，释放内存。 常见的垃圾回收算法： 标记-清除（Mark-Sweep）： 标记所有存活的对象，清除未标记的对象。 缺点：产生内存碎片。 标记-整理（Mark-Compact）： 标记所有存活的对象，将存活对象移动到内存的一端，清除剩余内存。 优点：避免内存碎片。 复制算法（Copying）： 将内存分为两块，每次只使用一块，将存活对象复制到另一块，清除当前块。 优点：避免内存碎片，适合新生代。 分代收集（Generational Collection）： 根据对象的生命周期将堆内存分为新生代和老年代，分别采用不同的垃圾回收算法。 3. JVM 在项目中的运用 3.1 JVM 调优 3.1.1 内存设置 堆内存： -Xms：初始堆大小。 -Xmx：最大堆大小。 新生代与老年代比例： -XX:NewRatio：新生代与老年代的比例。 -XX:SurvivorRatio：Eden 区与 Survivor 区的比例。 3.1.2 垃圾回收器选择 串行垃圾回收器：-XX:+UseSerialGC，适用于单核 CPU。 并行垃圾回收器：-XX:+UseParallelGC，适用于多核 CPU。 G1 垃圾回收器：-XX:+UseG1GC，适用于大内存应用。 3.2 性能监控与问题排查 3.2.1 监控工具 jstat：监控 JVM 统计信息，如堆内存使用情况、垃圾回收次数等。 jmap：生成堆内存快照，分析内存占用。 jstack：生成线程快照，排查死锁或线程阻塞问题。 VisualVM：图形化工具，监控内存、线程、CPU 使用情况。 3.2.2 常见问题与解决方案 内存泄漏：使用 jmap 生成堆转储文件，分析对象引用链，找到未释放的对象。 CPU 占用过高：使用 jstack 查看线程堆栈，定位高 CPU 占用的线程。 频繁 Full GC：调整堆内存大小或优化垃圾回收器参数。 3.3 本地方法接口（JNI） 用途：调用本地方法（如 C/C++ 代码），适用于需要高性能或调用现有库的场景。 流程： 在 Java 中声明本地方法。 使用 javah 生成头文件。 在 C/C++ 中实现本地方法。 将本地库加载到 JVM 中。 4. 实践建议 深入理解 JVM 原理：通过阅读官方文档和相关书籍，掌握 JVM 的核心概念和工作机制。 结合实际项目调优：根据应用场景调整 JVM 参数，监控性能指标，优化垃圾回收策略。 使用工具排查问题：熟练掌握 jstat、jmap、jstack 等工具，快速定位和解决性能问题。 关注 JVM 发展趋势：了解新版本 JVM 的特性和优化，如 ZGC、GraalVM 等。 5. 总结 JVM 是 Java 生态系统的核心，理解其原理和调优方法对于开发高性能、稳定的 Java 应用至关重要。通过深入学习 JVM 的内存管理、类加载机制、执行引擎等核心组件，并结合实际项目中的调优和问题排查，可以显著提升应用的性能和可靠性。\n","date":"2024-12-12T17:23:34+08:00","permalink":"https://deisbeir.github.io/p/jvm/","title":"Jvm"},{"content":"策略模式 模式的意图 在软件开发中，经常会遇到需要根据不同的条件来实现不同行为的场景。这种场景下，策略模式（Strategy Pattern）就是一种非常有用的设计模式。\n策略模式属于行为型模式，允许我们定义一系列算法，并将其封装在独立的策略类中，使得它们可以互相替换。通过使用策略模式，我们能够灵活地选择和切换不同的算法，而无需修改原有的代码，替代⼤量 if else 的逻辑。\n动机 当存在多种实现方式，且需要在运行时动态选择具体实现时，策略模式非常有用。例如，一个购物应用可能需要根据用户的会员等级来计算折扣，不同等级对应不同的计算方式，这时就可以使用策略模式来实现。 当存在一组类似的行为，只是实现细节略有不同，但又不希望通过继承来添加新的子类时，策略模式也很适用。它将这组行为封装在独立的策略类中，并通过委托的方式在上下文对象中使用。 例如 支付方式选择：一个电子商务平台可以根据用户的选择来使用不同的支付策略，例如信用卡支付、支付宝支付、微信支付等。 类结构 在策略模式中，有三个核心角色：上下文（Context）、策略接口（Strategy）和具体策略类（Concrete Strategy）。\n上下文（Context）：封装了具体策略的执行逻辑，提供给客户端使用的接口。上下文通常包含一个指向策略接口的引用，用于调用具体策略的方法。 策略接口（Strategy）：定义了一组算法或行为的公共接口，所有具体策略都必须实现该接口。 具体策略类（Concrete Strategy）：实现了策略接口，提供了具体的算法或行为。 代码示例 接下来以支付方式选择为例，展示代码\n上下文类\n1 2 3 4 5 6 7 8 9 10 11 12 // 上下文类 public class PaymentContext { private PaymentStrategy paymentStrategy; public PaymentContext(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void pay(double amount) { paymentStrategy.pay(amount); } } 策略接口\n1 2 3 4 //策略接口 public interface PaymentStrategy { void pay(double amount); } 策略接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //具体策略类 public class CreditCardPayment implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } } public class WeChatPay implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 // 使用示例 public class Main { public static void main(String[] args) { PaymentStrategy strategy = new CreditCardPayment(); PaymentContext context = new PaymentContext(strategy); context.pay(100.0); strategy = new WeChatPay(); context = new PaymentContext(strategy); context.pay(200.0); } } 输出\n1 2 使用信用卡支付：100.0 使用微信支付：200.0 策略模式的优缺点 策略模式的优点包括：\n松耦合：策略模式将不同的策略封装在独立的类中，与上下文对象解耦，增加了代码的灵活性和可维护性。 易于扩展：可以通过添加新的策略类来扩展系统的功能，无需修改现有代码。 符合开闭原则：对于新的策略，无需修改上下文对象，只需要实现新的策略接口即可。 策略模式的缺点包括：\n类数量增多：每个具体策略都需要一个独立的类，如果策略较多，将导致类的数量增加。 上层必须知道所有策略类：上层模块必须知道有哪些策略，并选择合适的策略进行使用，这与迪米特法则是相违背的。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题，否则日后的系统维护就会成为一个烫手山芋。\n策略模式的优化 使用Map取消 Context 类 我们可以将策略实现类放进 Map 中，根据 key 去选择具体的策略，就不必事先定义 Context 类。\n1 2 3 4 5 6 7 8 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategy\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, new CreditCardPayment()); map.put(\u0026#34;WECHAT_PAY\u0026#34;,new WeChatPay()); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 策略枚举解决策略类膨胀 策略枚举可以解决策略类过多的问题。\n我们对原装的策略模式进行改造，把原有定义在抽象策略中的方法移植到枚举中，让枚举成员成为一个具体策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Slf4j public enum PaymentStrategyEnum { CREDIT_CARD { @Override public void pay(double amount) { log.info(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } }, WECHAT_PAY { @Override public void pay(double amount) { log.info(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } }; public abstract void pay(double amount); } 在上面的代码中，我们定义了一个枚举类型 PaymentStrategy，其中包含两个枚举常量 CREDIT_CARD 和 WECHAT_PAY。每个枚举常量都重写了 pay() 方法，用于具体的支付逻辑\n1 2 3 4 5 6 7 8 9 // 使用示例 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategyEnum\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, PaymentStrategyEnum.CREDIT_CARD); map.put(\u0026#34;WECHAT_PAY\u0026#34;, PaymentStrategyEnum.WECHAT_PAY); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 注意：策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是 public、final、static 的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。\nSpringBoot中的策略模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public interface Test { void print(String name); } @Service(\u0026#34;testA\u0026#34;) @Slf4j public class TestA implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类A\u0026#34;+name); } } @Service(\u0026#34;testB\u0026#34;) @Slf4j public class TestB implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类B\u0026#34;+name); } } 使用的时候 @Autowired 或者 @Resource 即可，SpringBoot会帮我们把实现类自动注入注入Map。\n1 2 3 4 5 @Resource private Map\u0026lt;String,Test\u0026gt; map; Test test = map.get(\u0026#34;你想拿出的具体策略类\u0026#34;); test.print(\u0026#34;hello world\u0026#34;); 总结 策略模式是一种强大而灵活的设计模式，它可以帮助我们处理不同的算法或行为，并使系统更具可维护性和扩展性。通过封装具体的策略类和使用上下文对象，我们可以轻松地选择和切换不同的策略，而无需修改现有的代码。\n","date":"2024-12-10T23:48:54+08:00","permalink":"https://deisbeir.github.io/p/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","title":"策略模式"},{"content":"常见设计模式总结 我打算再理一遍常见的设计模式以加深印象，在这里先记录最基本的一些概念。\n什么是设计模式？ 设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，你可以根据需要进行定制，以解决代码中反复出现的设计问题。\n模式不是一段具体的代码，而是一个解决特定问题的通用概念。你可以遵循模式的思路，实现一个适合你自己程序实际情况的解决方案。\n为什么应该学习设计模式？ 设计模式是解决软件设计中常见问题的经过验证的工具包。它会教你如何使用面向对象设计的原则来解决各种问题。\n设计模式定义了一种通用的语言，团队成员可以使用它更高效地进行沟通。能更好的应对变更。同时在解决某些问题时会给出灵感。\n实际上，不使用设计模式也可以完成很多程序、项目，但使用设计模式会帮你避免后续的很多麻烦、节约沟通成本、使你的代码更加优雅。\n每个设计模式都可以通过以下几个部分来理解 模式的意图：简要描述问题和解决方案。 动机：进一步解释问题以及模式如何提供解决方案。 类结构：展示模式中每个部分以及它们之间的关系。 代码示例：使用一种流行的编程语言编写的代码示例，帮助更容易理解模式背后的思想。 六大设计原则 单一职责原则 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。\n该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：\n一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 开放封闭原则 开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n里式替换原则 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\n迪米特法则 迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)。\n迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n接口隔离原则 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。\n要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。\n接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\n单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。\n由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。\n使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。\n合成复用原则(CRP) 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。\n简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。\n类图基础 ","date":"2024-12-10T22:54:14+08:00","permalink":"https://deisbeir.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/","title":"设计模式基础"},{"content":"这是我的第一篇博客 我会尽可能的记录我所学习的内容！\n","date":"2024-12-10T21:48:01+08:00","permalink":"https://deisbeir.github.io/p/hellow/","title":"Hellow"}]