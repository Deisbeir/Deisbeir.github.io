[{"content":"策略模式 模式的意图 在软件开发中，经常会遇到需要根据不同的条件来实现不同行为的场景。这种场景下，策略模式（Strategy Pattern）就是一种非常有用的设计模式。\n策略模式属于行为型模式，允许我们定义一系列算法，并将其封装在独立的策略类中，使得它们可以互相替换。通过使用策略模式，我们能够灵活地选择和切换不同的算法，而无需修改原有的代码，替代⼤量 if else 的逻辑。\n动机 当存在多种实现方式，且需要在运行时动态选择具体实现时，策略模式非常有用。例如，一个购物应用可能需要根据用户的会员等级来计算折扣，不同等级对应不同的计算方式，这时就可以使用策略模式来实现。 当存在一组类似的行为，只是实现细节略有不同，但又不希望通过继承来添加新的子类时，策略模式也很适用。它将这组行为封装在独立的策略类中，并通过委托的方式在上下文对象中使用。 例如 支付方式选择：一个电子商务平台可以根据用户的选择来使用不同的支付策略，例如信用卡支付、支付宝支付、微信支付等。 类结构 在策略模式中，有三个核心角色：上下文（Context）、策略接口（Strategy）和具体策略类（Concrete Strategy）。\n上下文（Context）：封装了具体策略的执行逻辑，提供给客户端使用的接口。上下文通常包含一个指向策略接口的引用，用于调用具体策略的方法。 策略接口（Strategy）：定义了一组算法或行为的公共接口，所有具体策略都必须实现该接口。 具体策略类（Concrete Strategy）：实现了策略接口，提供了具体的算法或行为。 代码示例 接下来以支付方式选择为例，展示代码\n上下文类\n1 2 3 4 5 6 7 8 9 10 11 12 // 上下文类 public class PaymentContext { private PaymentStrategy paymentStrategy; public PaymentContext(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void pay(double amount) { paymentStrategy.pay(amount); } } 策略接口\n1 2 3 4 //策略接口 public interface PaymentStrategy { void pay(double amount); } 策略接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //具体策略类 public class CreditCardPayment implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } } public class WeChatPay implements PaymentStrategy { public void pay(double amount) { System.out.println(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 // 使用示例 public class Main { public static void main(String[] args) { PaymentStrategy strategy = new CreditCardPayment(); PaymentContext context = new PaymentContext(strategy); context.pay(100.0); strategy = new WeChatPay(); context = new PaymentContext(strategy); context.pay(200.0); } } 输出\n1 2 使用信用卡支付：100.0 使用微信支付：200.0 策略模式的优缺点 策略模式的优点包括：\n松耦合：策略模式将不同的策略封装在独立的类中，与上下文对象解耦，增加了代码的灵活性和可维护性。 易于扩展：可以通过添加新的策略类来扩展系统的功能，无需修改现有代码。 符合开闭原则：对于新的策略，无需修改上下文对象，只需要实现新的策略接口即可。 策略模式的缺点包括：\n类数量增多：每个具体策略都需要一个独立的类，如果策略较多，将导致类的数量增加。 上层必须知道所有策略类：上层模块必须知道有哪些策略，并选择合适的策略进行使用，这与迪米特法则是相违背的。 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题，否则日后的系统维护就会成为一个烫手山芋。\n策略模式的优化 使用Map取消 Context 类 我们可以将策略实现类放进 Map 中，根据 key 去选择具体的策略，就不必事先定义 Context 类。\n1 2 3 4 5 6 7 8 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategy\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, new CreditCardPayment()); map.put(\u0026#34;WECHAT_PAY\u0026#34;,new WeChatPay()); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 策略枚举解决策略类膨胀 策略枚举可以解决策略类过多的问题。\n我们对原装的策略模式进行改造，把原有定义在抽象策略中的方法移植到枚举中，让枚举成员成为一个具体策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Slf4j public enum PaymentStrategyEnum { CREDIT_CARD { @Override public void pay(double amount) { log.info(\u0026#34;使用信用卡支付：\u0026#34; + amount); // 具体的支付逻辑 } }, WECHAT_PAY { @Override public void pay(double amount) { log.info(\u0026#34;使用微信支付：\u0026#34; + amount); // 具体的支付逻辑 } }; public abstract void pay(double amount); } 在上面的代码中，我们定义了一个枚举类型 PaymentStrategy，其中包含两个枚举常量 CREDIT_CARD 和 WECHAT_PAY。每个枚举常量都重写了 pay() 方法，用于具体的支付逻辑\n1 2 3 4 5 6 7 8 9 // 使用示例 public static void main(String[] args) { Map\u0026lt;String, PaymentStrategyEnum\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;CREDIT_CARD\u0026#34;, PaymentStrategyEnum.CREDIT_CARD); map.put(\u0026#34;WECHAT_PAY\u0026#34;, PaymentStrategyEnum.WECHAT_PAY); map.get(\u0026#34;CREDIT_CARD\u0026#34;).pay(100.0); map.get(\u0026#34;WECHAT_PAY\u0026#34;).pay(200.0); } 注意：策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是 public、final、static 的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。\nSpringBoot中的策略模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public interface Test { void print(String name); } @Service(\u0026#34;testA\u0026#34;) @Slf4j public class TestA implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类A\u0026#34;+name); } } @Service(\u0026#34;testB\u0026#34;) @Slf4j public class TestB implements Test{ @Override public void print(String name) { log.info(\u0026#34;实现类B\u0026#34;+name); } } 使用的时候 @Autowired 或者 @Resource 即可，SpringBoot会帮我们把实现类自动注入注入Map。\n1 2 3 4 5 @Resource private Map\u0026lt;String,Test\u0026gt; map; Test test = map.get(\u0026#34;你想拿出的具体策略类\u0026#34;); test.print(\u0026#34;hello world\u0026#34;); 总结 策略模式是一种强大而灵活的设计模式，它可以帮助我们处理不同的算法或行为，并使系统更具可维护性和扩展性。通过封装具体的策略类和使用上下文对象，我们可以轻松地选择和切换不同的策略，而无需修改现有的代码。\n","date":"2024-12-10T23:48:54+08:00","permalink":"https://deisbeir.github.io/p/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","title":"策略模式"},{"content":"常见设计模式总结 我打算再理一遍常见的设计模式以加深印象，在这里先记录最基本的一些概念。\n什么是设计模式？ 设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，你可以根据需要进行定制，以解决代码中反复出现的设计问题。\n模式不是一段具体的代码，而是一个解决特定问题的通用概念。你可以遵循模式的思路，实现一个适合你自己程序实际情况的解决方案。\n为什么应该学习设计模式？ 设计模式是解决软件设计中常见问题的经过验证的工具包。它会教你如何使用面向对象设计的原则来解决各种问题。\n设计模式定义了一种通用的语言，团队成员可以使用它更高效地进行沟通。能更好的应对变更。同时在解决某些问题时会给出灵感。\n实际上，不使用设计模式也可以完成很多程序、项目，但使用设计模式会帮你避免后续的很多麻烦、节约沟通成本、使你的代码更加优雅。\n每个设计模式都可以通过以下几个部分来理解 模式的意图：简要描述问题和解决方案。 动机：进一步解释问题以及模式如何提供解决方案。 类结构：展示模式中每个部分以及它们之间的关系。 代码示例：使用一种流行的编程语言编写的代码示例，帮助更容易理解模式背后的思想。 六大设计原则 单一职责原则 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。\n该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：\n一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 开放封闭原则 开闭原则的实现方法：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n里式替换原则 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\n迪米特法则 迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)。\n迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n接口隔离原则 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。\n要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。\n接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\n单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。\n由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。\n使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。\n合成复用原则(CRP) 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。\n简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。\n类图基础 ","date":"2024-12-10T22:54:14+08:00","permalink":"https://deisbeir.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/","title":"设计模式基础"},{"content":"这是我的第一篇博客 我会尽可能的记录我所学习的内容！\n","date":"2024-12-10T21:48:01+08:00","permalink":"https://deisbeir.github.io/p/hellow/","title":"Hellow"}]