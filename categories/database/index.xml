<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据库 on 德斯别尔-Des</title>
        <link>https://deisbeir.github.io/categories/database/</link>
        <description>Recent content in 数据库 on 德斯别尔-Des</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>德斯别尔-Des</copyright>
        <lastBuildDate>Mon, 30 Dec 2024 15:46:45 +0800</lastBuildDate><atom:link href="https://deisbeir.github.io/categories/database/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL</title>
        <link>https://deisbeir.github.io/p/mysql/</link>
        <pubDate>Mon, 30 Dec 2024 15:46:45 +0800</pubDate>
        
        <guid>https://deisbeir.github.io/p/mysql/</guid>
        <description>&lt;img src="https://deisbeir.github.io/p/mysql/show.png" alt="Featured image of post MySQL" /&gt;&lt;h3 id=&#34;什么是关系型数据库&#34;&gt;什么是关系型数据库？
&lt;/h3&gt;&lt;p&gt;顾名思义，关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。&lt;/p&gt;
&lt;h2 id=&#34;mysql-字段类型&#34;&gt;MySQL 字段类型
&lt;/h2&gt;&lt;p&gt;MySQL 字段类型可以简单分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数值类型&lt;/strong&gt;：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串类型&lt;/strong&gt;：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日期时间类型&lt;/strong&gt;：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql-索引&#34;&gt;MySQL 索引
&lt;/h2&gt;&lt;h4 id=&#34;mysql-查询缓存&#34;&gt;MySQL 查询缓存
&lt;/h4&gt;&lt;p&gt;MySQL 查询缓存是查询结果缓存。执行查询语句的时候，会先查询缓存，如果缓存中有对应的查询结果，就会直接返回。&lt;/p&gt;
&lt;p&gt;查询缓存会在同样的查询条件和数据情况下，直接返回缓存中的结果。但需要注意的是，查询缓存的匹配条件非常严格，任何细微的差异都会导致缓存无法命中。这里的查询条件包括查询语句本身、当前使用的数据库、以及其他可能影响结果的因素，如客户端协议版本号等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询缓存不命中的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何两个查询在任何字符上的不同都会导致缓存不命中。&lt;/li&gt;
&lt;li&gt;如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。&lt;/li&gt;
&lt;li&gt;缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-事务&#34;&gt;MySQL 事务
&lt;/h2&gt;&lt;h4 id=&#34;何谓事务&#34;&gt;何谓事务？
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;何谓数据库事务&#34;&gt;何谓数据库事务？
&lt;/h4&gt;&lt;p&gt;大多数情况下，我们在谈论事务的时候，如果没有特指&lt;strong&gt;分布式事务&lt;/strong&gt;，往往指的就是&lt;strong&gt;数据库事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。&lt;/p&gt;
&lt;p&gt;数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：&lt;strong&gt;要么全部执行成功,要么全部不执行&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;开启一个事务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;START&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TRANSACTION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;多条&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SQL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;语句&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SQL1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SQL2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;##&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;提交事务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COMMIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;img src=&#34;2.png&#34; alt=&#34;image-20241230163002562&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;p&gt;另外，关系型数据库（例如：&lt;code&gt;MySQL&lt;/code&gt;、&lt;code&gt;SQL Server&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt; 等）事务都有 &lt;strong&gt;ACID&lt;/strong&gt; 特性：&lt;/p&gt;
&lt;img src=&#34;3.png&#34; alt=&#34;image-20241230163002562&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;（&lt;code&gt;Atomicity&lt;/code&gt;）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;（&lt;code&gt;Consistency&lt;/code&gt;）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;（&lt;code&gt;Isolation&lt;/code&gt;）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;（&lt;code&gt;Durability&lt;/code&gt;）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;并发事务带来了哪些问题&#34;&gt;并发事务带来了哪些问题?
&lt;/h3&gt;&lt;p&gt;在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。&lt;/p&gt;
&lt;h4 id=&#34;脏读dirty-read&#34;&gt;脏读（Dirty read）
&lt;/h4&gt;&lt;p&gt;一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。&lt;/p&gt;
&lt;h4 id=&#34;丢失修改lost-to-modify&#34;&gt;丢失修改（Lost to modify）
&lt;/h4&gt;&lt;p&gt;在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。&lt;/p&gt;
&lt;h4 id=&#34;不可重复读unrepeatable-read&#34;&gt;不可重复读（Unrepeatable read）
&lt;/h4&gt;&lt;p&gt;指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。&lt;/p&gt;
&lt;h4 id=&#34;幻读phantom-read&#34;&gt;幻读（Phantom read）
&lt;/h4&gt;&lt;p&gt;幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。&lt;/p&gt;
&lt;h3 id=&#34;不可重复读和幻读有什么区别&#34;&gt;不可重复读和幻读有什么区别？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；&lt;/li&gt;
&lt;li&gt;幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。&lt;/p&gt;
&lt;h3 id=&#34;并发事务的控制方式有哪些&#34;&gt;并发事务的控制方式有哪些？
&lt;/h3&gt;&lt;p&gt;MySQL 中并发事务的控制方式无非就两种：&lt;strong&gt;锁&lt;/strong&gt; 和 &lt;strong&gt;MVCC&lt;/strong&gt;。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁&lt;/strong&gt; 控制方式下会通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 &lt;strong&gt;读写锁&lt;/strong&gt; 来实现并发控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享锁（S 锁）&lt;/strong&gt;：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他锁（X 锁）&lt;/strong&gt;：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 &lt;strong&gt;表级锁(table-level locking)&lt;/strong&gt; 和 &lt;strong&gt;行级锁(row-level locking)&lt;/strong&gt; 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVCC&lt;/strong&gt; 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。&lt;/p&gt;
&lt;p&gt;MVCC 在 MySQL 中实现所依赖的手段主要是: &lt;strong&gt;隐藏字段、read view、undo log&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;undo log : undo log 用于记录某行数据的多个版本的数据。&lt;/li&gt;
&lt;li&gt;read view 和 隐藏字段 : 用来判断当前版本数据的可见性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sql-标准定义了哪些事务隔离级别&#34;&gt;SQL 标准定义了哪些事务隔离级别?
&lt;/h3&gt;&lt;p&gt;SQL 标准定义了四个隔离级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;READ-UNCOMMITTED(读取未提交)&lt;/strong&gt; ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;READ-COMMITTED(读取已提交)&lt;/strong&gt; ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REPEATABLE-READ(可重复读)&lt;/strong&gt; ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SERIALIZABLE(可串行化)&lt;/strong&gt; ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;隔离级别&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;脏读&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;不可重复读&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;幻读&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;READ-UNCOMMITTED&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;READ-COMMITTED&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;REPEATABLE-READ&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;√&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;SERIALIZABLE&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;×&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;mysql-的隔离级别是基于锁实现的吗&#34;&gt;MySQL 的隔离级别是基于锁实现的吗？
&lt;/h3&gt;&lt;p&gt;MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。&lt;/p&gt;
&lt;p&gt;SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。&lt;/p&gt;
&lt;p&gt;MySQL InnoDB 存储引擎的默认支持的隔离级别是 &lt;strong&gt;REPEATABLE-READ（可重读）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;mysql-性能怎么优化&#34;&gt;MySQL 性能怎么优化？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. 抓住核心：慢 SQL 定位与分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能优化的第一步永远是找到瓶颈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控工具：&lt;/strong&gt; 介绍常用的慢 SQL 监控工具，如 &lt;strong&gt;MySQL 慢查询日志&lt;/strong&gt;、&lt;strong&gt;Performance Schema&lt;/strong&gt; 等，说明你对这些工具的熟悉程度以及如何通过它们定位问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EXPLAIN 命令：&lt;/strong&gt; 详细说明 &lt;code&gt;EXPLAIN&lt;/code&gt; 命令的使用，分析查询计划、索引使用情况，可以结合实际案例展示如何解读分析结果，比如执行顺序、索引使用情况、全表扫描等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 由点及面：索引、表结构和 SQL 优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定位到慢 SQL 后，接下来就要针对具体问题进行优化。 这里可以重点介绍索引、表结构和 SQL 编写规范等方面的优化技巧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;索引优化：&lt;/strong&gt; 这是 MySQL 性能优化的重点，可以介绍索引的创建原则、覆盖索引、最左前缀匹配原则等。如果能结合你项目的实际应用来说明如何选择合适的索引，会更加分一些。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表结构优化：&lt;/strong&gt; 优化表结构设计，包括选择合适的字段类型、避免冗余字段、合理使用范式和反范式设计等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 优化：&lt;/strong&gt; 避免使用 &lt;code&gt;SELECT *&lt;/code&gt;、尽量使用具体字段、使用连接查询代替子查询、合理使用分页查询、批量操作等，都是 SQL 编写过程中需要注意的细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 进阶方案：架构优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当面试官对基础优化知识比较满意时，可能会深入探讨一些架构层面的优化方案。以下是一些常见的架构优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读写分离：&lt;/strong&gt; 将读操作和写操作分离到不同的数据库实例，提升数据库的并发处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分库分表：&lt;/strong&gt; 将数据分散到多个数据库实例或数据表中，降低单表数据量，提升查询效率。但要权衡其带来的复杂性和维护成本，谨慎使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据冷热分离&lt;/strong&gt;：根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存机制：&lt;/strong&gt; 使用 Redis 等缓存中间件，将热点数据缓存到内存中，减轻数据库压力。这个非常常用，提升效果非常明显，性价比极高！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 其他优化手段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了慢 SQL 定位、索引优化和架构优化，还可以提及一些其他优化手段，展示你对 MySQL 性能调优的全面理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接池配置：&lt;/strong&gt; 配置合理的数据库连接池（如 &lt;strong&gt;连接池大小&lt;/strong&gt;、&lt;strong&gt;超时时间&lt;/strong&gt; 等），能够有效提升数据库连接的效率，避免频繁的连接开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件配置：&lt;/strong&gt; 提升硬件性能也是优化的重要手段之一。使用高性能服务器、增加内存、使用 &lt;strong&gt;SSD&lt;/strong&gt; 硬盘等硬件升级，都可以有效提升数据库的整体性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读写分离：&lt;/strong&gt; 将读操作和写操作分离到不同的数据库实例，提升数据库的并发处理能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分库分表：&lt;/strong&gt; 将数据分散到多个数据库实例或数据表中，降低单表数据量，提升查询效率。但要权衡其带来的复杂性和维护成本，谨慎使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据冷热分离&lt;/strong&gt;：根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存机制：&lt;/strong&gt; 使用 Redis 等缓存中间件，将热点数据缓存到内存中，减轻数据库压力。这个非常常用，提升效果非常明显，性价比极高！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 其他优化手段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了慢 SQL 定位、索引优化和架构优化，还可以提及一些其他优化手段，展示你对 MySQL 性能调优的全面理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接池配置：&lt;/strong&gt; 配置合理的数据库连接池（如 &lt;strong&gt;连接池大小&lt;/strong&gt;、&lt;strong&gt;超时时间&lt;/strong&gt; 等），能够有效提升数据库连接的效率，避免频繁的连接开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件配置：&lt;/strong&gt; 提升硬件性能也是优化的重要手段之一。使用高性能服务器、增加内存、使用 &lt;strong&gt;SSD&lt;/strong&gt; 硬盘等硬件升级，都可以有效提升数据库的整体性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;本文内容基本来自&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/mysql-questions-01.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JavaGuide&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis 知识点</title>
        <link>https://deisbeir.github.io/p/redis-%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
        <pubDate>Tue, 17 Dec 2024 23:39:10 +0800</pubDate>
        
        <guid>https://deisbeir.github.io/p/redis-%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
        <description>&lt;img src="https://deisbeir.github.io/p/redis-%E7%9F%A5%E8%AF%86%E7%82%B9/show.png" alt="Featured image of post Redis 知识点" /&gt;&lt;h2 id=&#34;redis-相关内容记录&#34;&gt;Redis 相关内容记录
&lt;/h2&gt;&lt;p&gt;Redis 是一个高性能的内存数据存储系统，广泛应用于缓存、消息队列、实时分析等领域。&lt;/p&gt;
&lt;h3 id=&#34;1-内存存储机制&#34;&gt;1. 内存存储机制
&lt;/h3&gt;&lt;p&gt;Redis 的数据存储在内存中，这意味着数据访问速度非常快。然而，内存存储也带来了数据持久化的问题。&lt;/p&gt;
&lt;h3 id=&#34;2-数据结构&#34;&gt;2. 数据结构
&lt;/h3&gt;&lt;p&gt;Redis 支持多种数据结构，每种都有其独特的实现和适用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符串（String）&lt;/strong&gt;：Redis 的基本数据类型，支持动态字符串和原子操作，适用于存储简单键值对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希（Hash）&lt;/strong&gt;：由键值对组成的集合，内部使用哈希表实现，适合存储对象的多个字段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列表（List）&lt;/strong&gt;：有序的字符串集合，使用双向链表实现，适合在两端进行高效插入和删除操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合（Set）&lt;/strong&gt;：无序的唯一字符串集合，内部使用哈希表实现，支持高效的成员检查和集合运算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序集合（Sorted Set）&lt;/strong&gt;：集合的扩展，每个成员关联一个分数，使用哈希表和跳表实现，支持有序操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位图（Bitmap）&lt;/strong&gt;：通过位操作在字符串上实现，适用于存储大量的布尔值，非常节省内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HyperLogLog&lt;/strong&gt;：一种概率数据结构，用于估计集合中唯一元素的数量，适用于大数据量的统计场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地理空间索引（Geospatial Index）&lt;/strong&gt;：使用有序集合和 geohash 实现，支持高效的地理范围查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-内存管理&#34;&gt;3. 内存管理
&lt;/h3&gt;&lt;p&gt;Redis 使用 slab 分配器管理内存，减少内存碎片并提高缓存局部性。数据淘汰策略如 LRU、TTL 和随机淘汰，帮助管理内存使用。&lt;/p&gt;
&lt;h3 id=&#34;4-持久化&#34;&gt;4. 持久化
&lt;/h3&gt;&lt;p&gt;Redis 提供了两种持久化机制：RDB（快照持久化）和 AOF（日志持久化），它们各自有不同的工作原理和适用场景。以下是对这两种机制的详细解析：&lt;/p&gt;
&lt;h5 id=&#34;41-rdb-redis-database-backup&#34;&gt;4.1. RDB (Redis Database Backup)
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;RDB 快照&lt;/strong&gt;：定期将内存中的数据快照保存到磁盘，形成一个 RDB 文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;: RDB 通过 fork 一个子进程来生成数据快照，并将快照保存到磁盘。主进程在此期间继续处理请求，不会被阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置&lt;/strong&gt;: 通过 &lt;code&gt;save&lt;/code&gt; 指令配置快照策略，例如 &lt;code&gt;save 900 1&lt;/code&gt; 表示在900秒内有1次修改时进行保存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能考虑&lt;/strong&gt;: 使用写时复制（Copy-On-Write）技术，避免内存复制开销，确保主进程性能不受影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优缺点&lt;/strong&gt;: 优点是文件紧凑，适合快速恢复；缺点是可能会丢失最近修改的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;42-aof-append-only-file&#34;&gt;4.2. AOF (Append Only File)
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;AOF 日志&lt;/strong&gt;：记录每一个写操作，确保数据的持久化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;: AOF 通过追加日志文件记录每一次写操作，恢复时重新执行这些操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置&lt;/strong&gt;: 通过 &lt;code&gt;appendfsync&lt;/code&gt; 选项控制同步频率，有 &lt;code&gt;always&lt;/code&gt;、&lt;code&gt;everysec&lt;/code&gt; 和 &lt;code&gt;no&lt;/code&gt; 三个可选值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件重写&lt;/strong&gt;: 定期重写 AOF 文件，生成只包含恢复数据所需最小操作的文件，减少文件大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优缺点&lt;/strong&gt;: 优点是数据安全性高，缺点是文件较大且恢复速度较慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;43-rdb-与-aof-的结合使用&#34;&gt;4.3. RDB 与 AOF 的结合使用
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优先级&lt;/strong&gt;: Redis 启动时优先加载 AOF 文件，若 AOF 文件不可用，则加载 RDB 文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;: 两者独立进行，但 Redis 会自动处理潜在的一致性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;44-持久化与性能&#34;&gt;4.4. 持久化与性能
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;影响&lt;/strong&gt;: 过于频繁的持久化操作可能影响性能，需根据实际场景调整策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化&lt;/strong&gt;: 可通过调整配置或优化硬件（如使用更快的磁盘）来缓解性能压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-redis-高可用架构设计&#34;&gt;5. Redis 高可用架构设计
&lt;/h3&gt;&lt;p&gt;Redis 的高可用性架构设计旨在确保系统在故障发生时仍能继续提供服务，通常通过复制、监控和自动故障转移机制来实现。&lt;/p&gt;
&lt;h5 id=&#34;51-主从复制master-slave-replication&#34;&gt;5.1. 主从复制（Master-Slave Replication）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;主节点（Master）处理读写请求，从节点（Slave）复制主节点的数据。&lt;/li&gt;
&lt;li&gt;从节点可以提供读扩展和数据冗余。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障转移&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;手动故障转移：手动将从节点升级为主节点。&lt;/li&gt;
&lt;li&gt;自动故障转移：结合 Sentinel 实现自动故障检测和转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slaveof&lt;/code&gt; 命令配置从节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replica-serve-stale-data&lt;/code&gt; 控制从节点在连接不上主节点时的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;52-sentinel监控与自动故障转移&#34;&gt;5.2. Sentinel（监控与自动故障转移）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;监控 Redis 实例的状态（主从节点）。&lt;/li&gt;
&lt;li&gt;检测故障并自动进行故障转移。&lt;/li&gt;
&lt;li&gt;通知客户端主节点变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;配置 Sentinel 节点，指定监控的主节点和从节点。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;quorum&lt;/code&gt; 决定多少 Sentinel 节点同意才能进行故障转移。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;down-after-milliseconds&lt;/code&gt; 等参数调整故障检测的敏感度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作流程&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Sentinel 定期检查 Redis 实例的心跳。&lt;/li&gt;
&lt;li&gt;当主节点故障时， Sentinel 选举一个从节点升级为主节点。&lt;/li&gt;
&lt;li&gt;其他从节点重新配置指向新的主节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;53-redis-cluster集群模式&#34;&gt;5.3. Redis Cluster（集群模式）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高可用性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;自动分片，数据分布在多个节点。&lt;/li&gt;
&lt;li&gt;每个节点有多个副本（从节点），支持自动故障转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据分片&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;数据根据键的哈希值分布到 16384 个槽中。&lt;/li&gt;
&lt;li&gt;每个槽由一个主节点负责，可配置多个从节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障转移&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当主节点故障时，集群自动选择一个从节点升级为主节点。&lt;/li&gt;
&lt;li&gt;客户端需支持集群模式，以处理槽的重新分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置与管理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;redis-cli --cluster&lt;/code&gt; 命令进行集群的创建和管理。&lt;/li&gt;
&lt;li&gt;配置 &lt;code&gt;cluster-node-timeout&lt;/code&gt; 等参数调整集群行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6redis-缓存击穿缓存雪崩缓存穿透&#34;&gt;6.Redis 缓存击穿、缓存雪崩、缓存穿透
&lt;/h3&gt;&lt;p&gt;在高并发场景下，缓存系统（如 Redis）可能会遇到缓存击穿、缓存雪崩和缓存穿透等问题。这些问题会导致数据库压力骤增，甚至引发系统崩溃。&lt;/p&gt;
&lt;h5 id=&#34;对比&#34;&gt;对比
&lt;/h5&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;热点数据失效，大量请求直接访问数据库。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;热点数据过期或缓存未命中。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;加锁、永不过期、热点数据预热。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;大量缓存数据同时失效，导致数据库压力骤增。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;缓存数据设置相同过期时间或 Redis 宕机。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;分散过期时间、多级缓存、高可用架构、限流与降级。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;查询不存在的数据，缓存和数据库均未命中，导致每次请求都访问数据库。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;恶意请求或非法查询。&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;缓存空值、布隆过滤器、参数校验。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;最佳实践&#34;&gt;最佳实践
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;合理设置缓存过期时间&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;避免缓存集中失效，设置随机过期时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控与报警&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;实时监控缓存命中率和数据库查询量，及时发现异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限流与降级&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在缓存失效时，通过限流和降级保护数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据预热&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;提前加载热点数据到缓存中，避免冷启动问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用布隆过滤器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;对于可能不存在的数据，使用布隆过滤器减少无效查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
